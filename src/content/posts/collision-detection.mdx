---
title: "SAT Collision Detection"
subtitle: "An explanation of the Separating Axis Theorem"
excerpt: 'Have you ever played a computer game and started asking yourself... Wait a second, how does the computer actually know how to stop moving my character when I hit the ground? Or when I run into an obstacle? It is quite awesome that all of this "just" works... but how exactly does the computer do it?'
cover: "/assets/blog/tall-buildings.jpg"
date: "2022-10-13"
author:
  name: Rico Trebeljahr
  picture: "/assets/blog/profile.jpeg"

---

# {title}

#### {subtitle}

<p>{excerpt}</p>

This post is going to answer that question, by explaining one particular algorithm that can be used to tackle this sort of problem. That Algorithm is based on a mathematical idea known as the "Separating Axis Theorem". 

The main idea behind this theorem is simple. If you can draw a line *between* two shapes, without touching either shape, the two shapes don't collide. This line, that separates the two shapes is known as a "separating axis", and hence the name: "Separating Axis Theorem". But how does the computer search for these lines? Shadows!

## How to Project a Line

In linear algebra a projection is essentially what happens if you were to shine a light onto an object from very far away. The object would cast a shadow onto the wall – this shadow is mathematically known as a "projection".

Because for the demo's of this article we will work only in two dimensions the "wall" becomes a simple line and the object is just a point, but the idea, of shining a light onto the point and tracking where the shadow falls onto the line stays the same. That is what a projection is!

Points can be modeled with vectors, you can think of the vectors as little arrows pointing to a location somewhere in space. 

Usually vectors are notated like this:

$$
\begin{bmatrix}
   x \\
   y
\end{bmatrix}
or 
\begin{bmatrix}
   2 \\
   5
\end{bmatrix}
or
\begin{bmatrix}
   -1 \\
   20
\end{bmatrix}
or 
\begin{bmatrix}
   a \\
   b
\end{bmatrix}
$$

Which is useful since this way we can see the amount that the vector goes into each of the directions x and y.

A straight line can be defined by two points. Please try dragging around the points in the demo below to move the lines and the arrows around!

<PointAndLineDemo/>

The direction of the line can be calculated by getting the difference between two of the points it is passing through. Each line has two directions – depending on the order of subtraction of the points. If you subtract A from B you get one direction and B from A gives you the other. The only difference between the two directions are the signs in front of the vector components, flip both signs and you would get the "opposite" direction. 

There are a lot of fancy things that can be done with vectors, even just in 2D, so let's write a class that implements those functionalities: 

```typescript
const precision = 0.000001;
export class Vector2 {
  public components: [number, number, number];

  constructor(x: number, y: number) {
    this.components = [x, y, 1];
  }

  get x() {
    return this.components[0];
  }
  set x(newX: number) {
    this.components[0] = newX;
  }
  get y() {
    return this.components[1];
  }
  set y(newY: number) {
    this.components[1] = newY;
  }

  mag() {
    return Math.sqrt(this.mag2());
  }

  mag2() {
    return this.dot(this);
  }

  divScalar(scalar: number) {
    return new Vector2(this.x / scalar, this.y / scalar);
  }

  multScalar(scalar: number) {
    return new Vector2(this.x * scalar, this.y * scalar);
  }

  projectOnLine(A: Vector2, B: Vector2) {
    const AP = this.sub(A);
    const AB = B.sub(A);
    return A.add(AB.multScalar(AP.dot(AB) / AB.mag2()));
  }

  unit() {
    return this.divScalar(this.mag());
  }

  perp() {
    return new Vector2(this.y, -this.x);
  }

  getNormal() {
    return this.perp().unit();
  }

  sub(other: Vector2) {
    return new Vector2(this.x - other.x, this.y - other.y);
  }

  add(other: Vector2) {
    return new Vector2(this.x + other.x, this.y + other.y);
  }

  dot(other: Vector2) {
    return this.x * other.x + this.y * other.y;
  }

  copy() {
    return new Vector2(this.x, this.y);
  }

  transform(matrix: Matrix) {
    const newX = matrix.a * this.x + matrix.b * this.y + matrix.c;
    const newY = matrix.d * this.x + matrix.e * this.y + matrix.f;
    this.x = newX;
    this.y = newY;
    return this;
  }

  equals(other: Vector2) {
    return (
      Math.abs(other.x - this.x) < precision &&
      Math.abs(other.y - this.y) < precision
    );
  }

  perpDot(other: Vector2) {
    return this.perp().dot(other);
  }
}
```


Now there are a lot of little things in there that are necessary to understand before moving on: 
What are all these methods doing? perp, unit, dot, mag, mag2, transform, perpDot?!

Ok. Let's start disassembling them 1 by 1 and explain what each of them does along the way: 

mag is short for Magnitude which is just mathematical jargon for the length of a vector. If you imagine the vector giving you a location in space you could say, hmmm, if I were to walk there, how long would I have to walk? The answer to that can be easily found out by using the Pythagorean theorem. 

Where the x and y components form a right angle triangle and the hypotenuse of that triangle is the vector we are interested in. Hence the formula for the length of a vector is simply the Pythagorean theorem. 

$$
\begin{Vmatrix}
  x \\
  y
\end{Vmatrix} = \sqrt{x² + y²}
$$

In the formula above we use the squared magnitude, so the sqrt, can drop from the term. If we just implement the above in code, we get the below. 

## The Dot Product

The dot product of a vector is defined as adding up the multiples of it's components. Vectors can have multiple components, x,y,z etc. based on how many dimensions of space the vector is in, for these demos we keep everything super simple, and only worry about vectors in 2D. Those only have 2 components – x and y. 

Dot Products are extremely useful in mathematics and computer graphics. Mainly because they can be used to find out how far along one vector is if projected onto the other. This property is why we can see it appear in the above formula and why it will appear a lot more throughout this article.

<DotProductDemo />





Now that these basic ideas are out of the way, let's tackle casting shadows! Luckily there is a mathematical expression for how to calculate a projection from a point onto a line!

Given the Points A, B, and C, where C is the point we want to project and A and B are the two points defining the line, we can find the projection of C onto the line AB by using the following formula. 

projectionOfC = *A + (dot(AC, AB) / mag2(AB, AB)) \* AB*

The same formula can be also expressed in code:

```typescript
function projectOnLine(A: Vector2, B: Vector2, C: Vector2) {
    const AC = C.sub(A);
    const AB = B.sub(A);
    return A.add(AB.multScalar(AC.dot(AB) / AB.mag2()));
}
```

Drawing this out onto a canvas – a line going through A and B and an arrow going from A to C you would get the below! You can try dragging around the points A, B, and C to change the direction, position and length of the vector and the line.

<MatrixDemo />

A few notes on controls: For all the demos you should be able to drag around the polygons (shapes) themselves as well as the points making up the polygons. You can also click on a polygon to "select" it and then rotate it by holding down the A and D keys on your keyboard! 

## Projecting a Whole Polygon

The main idea for the SAT, is that these projections of points can become very useful, because they can help determine whether or not a single ray of light could shine through in between two polygons. The cool thing is, if there could be a light ray between two polygons, that means that they can not intersect! Otherwise, how could the light get through?

This means, that if there is place between the shadows of two polygons, there will be a place between the polygons themselves where the light can pass through which means that there is a separating axis (the ray of light) and we can safely say that the two polygons don't touch each other! Because we can shine a light through between them. So the goal now is this: find two shadows (projections) that don't overlap for the two polygons.

However to get there, we first need to be able to project a whole polygon onto a line. Luckily, a polygon is just a set of points. Usually these points are called vertices (singular vertex) in computer graphics. But if we project all the points we would still have to figure out which points actually are the "left" and "right" edge of the shadow.  

There are multiple approaches to do this, but one I find particularly fascinating and which is the one used down below in the demos is that of using a support function. 

Essentially a support function finds a point among a set of points (here the vertices of the polygon we want to project), that is furthest along in a particular direction. Now vectors can be thought of not only as points, but also as directions. Hence the idea of an arrow – "pointing" into a direction in space. 

The trick here is to run the polygon through the finding of support points for the two different directions of the line. AB and BA –> which will result in the two points furthest along these directions => which we can then use to project onto the line for getting the shadow. Here is the code for the support point function (it will be very useful for other algorithms in collision detection, like the GJK algorithm, later on) : 

```js
export function getSupportPoint(vertices: Vector2[], d: Vector2) {
  // initialize variables
  let highest = -Infinity;
  let support = new Vector2(0, 0);
  
  // loop over the vertices of the polygon
  for (let vertex of vertices) {
    // compute the dot product between the vertex and the direction
    const dot = vertex.dot(d);
	
    // keep track of the highest dot product and thereby the furthest point along the direction
    if (dot > highest) {
      highest = dot;
      support = vertex;
    }
  }
  
  // return the point with the highest dot product with the direction!
  return support;
}
```

We can then use those points to draw a polygon and it's projection onto the screen.

```typescript
export function drawProjection(
  ctx: CanvasRenderingContext2D,
  polys: Polygon | [Polygon, Polygon],
  p1: Vector2,
  p2: Vector2
) {
 

  // get directions for "up" and "down" the line
  const d2 = p2.sub(p1);
  const d1 = p1.sub(p2);

  // create translation matrix
  const origin = new Vector2(parseFloat(ctx.canvas.style.width) / 2, parseFloat(ctx.canvas.style.height) / 2);
  const toOrigin = getTranslationMatrix(origin.x, origin.y);
 
  // use translation matrix + scaling to create far apart line points
  // which goes through origin in the middle of the canvas 
  const len = Math.max(parseFloat(ctx.canvas.style.width), parseFloat(ctx.canvas.style.height));
  const l1 = d2.unit().multScalar(len).transform(toOrigin);
  const l2 = d2.unit().multScalar(-len).transform(toOrigin);

  // draw line onto which should be projected
  ctx.strokeStyle = "rgba(100, 100, 100, 0.5)";
  line(ctx, l2, l1);
  
  // get support points for each direction
  const s1 = getSupportPoint(poly.vertices, d1);
  const s2 = getSupportPoint(poly.vertices, d2);
  
  // get projection for each support point
  const projectedS1 = projectOnLine(l1, l2, s1);
  const projectedS2 = projectOnLine(l1, l2, s2);
  
  // draw shadow based on projections
  line(ctx, projectedS1, projectedS2);

  // also draw a dashed line between the projected and support points
  ctx.save();
  ctx.setLineDash([5, 15]);
  ctx.strokeStyle = "rgb(150, 150, 150)";
  line(ctx, s1, projectedS1);
  line(ctx, s2, projectedS2);
  ctx.restore();
}
```

<ProjectionDemo />

## Project for 2 Polygons 

All of this also works for 2 Polygons at once of course! The question we would like to answer given the two shadows is whether or not they overlap. Since the shadows are two line segments, that we know to be collinear we can use a simple test like the one below to check whether or not they overlap. 

```typescript
function onSegment(p: Vector2, q: Vector2, r: Vector2) {
  if (
    q.x <= Math.max(p.x, r.x) &&
    q.x >= Math.min(p.x, r.x) &&
    q.y <= Math.max(p.y, r.y) &&
    q.y >= Math.min(p.y, r.y)
  )
    return true;

  return false;
}

function doIntersect(a1: Vector2, a2: Vector2, b1: Vector2, b2: Vector2) {
  if (onSegment(a1, b1, a2)) return true;
  if (onSegment(a1, b2, a2)) return true;
  if (onSegment(b1, a1, b2)) return true;
  if (onSegment(b1, a2, b2)) return true;

  return false;
}
```

There are also versions of this test, which use the dot product to determine how far along the line the points are and by comparing the minimum and maximum against each other determine whether or not they overlap. Which algorithm we use doesn't matter so much in the end, the important thing is that we can test for the two shadows "overlapping" or not. In the example below, if the shadows overlap we change the color to red.

<ExampleWith2Polygons />

## The Last Idea

How should we pick the lines that we project onto? Isn't there an infinity of possible lines we could chose from? While this is technically correct, we only need to check a few lines to make sure that the shapes don't collide, namely the normal for each edge of the polygon. The concept of a normal is very very useful in computer graphics and linear algebra in general. The main idea of a normal is a vector that is perpendicular (at 90°) to another vector (or line). Usually each line has two normals – one in each direction, however when working with polygons one is usually interested in the normals facing out of the polygon. In a lot of computer graphics applications there are sometimes bugs where normals are inverted for some reason, which usually messes up the lighting calculations, because the shape is "wrapped" onto the outside.

<ShowWhatANormalIs/>

But for SAT, we can simply have a loop that goes over each of the normals of our Polygons in turn, and checks if the two shadows overlap. You can see that in the example below it cycling through the different normals, one by one. The only thing we are interested in from the normal is the direction, so we displace it towards the origin and draw a line passing in the same general direction that the normal was facing. Usually normals would be directly on the edge of the polygon. 

<AxisByAxis />

In the above example, if you make the shapes overlap, what do you notice about their shadows?

## Complete SAT

The loop we did, step by step with a delay above was just for visualization purposes, instead we can just check all of the normals at once and see: if all shadows overlap (and show up in red), then the shapes also have to overlap too and we can color them red! That's the whole meaning behind the separating axis theorem.

<SAT/>

This is all there is to a simple SAT collision detection algorithm. To sum up the algorithm: Cast shadows (projections) onto the normals of two polygons and check if the projections overlap. If you find a pair of projections that doesn't overlap, there is no collision. If all projections overlap, there is a collision.

Cool, so we are done now, right? Well, check this out: 

<SATWithConvexShapes />

Well... that didn't go to well huh? The problem is that what you just saw where so called "concave" shapes... All the polygons you've seen so far up to this point were "convex", and I took some precautions so that this is always the case.

Convex and concave are just two words to express that something bulges outwards or inwards. I remember them with the word "cave" as in concave. A cave goes inward, so does a concave object. In other words, concave shapes are shapes that have some kind of indentation in them. A star would be a concave shape, or a something like a V etc. To handle collisions with concave shapes is usually very tricky... Usually people just chop them up into simpler – convex – shapes and then make collision detection happening with them. Mostly people chop them up into triangles using a process called triangulation (which has many different algorithms for it...) So let's look at some.

### Triangulating Concave Shapes



Ok. Cool. We are done now. Right?

Well... almost.

There is still another loose end here! Namely, we don't yet prevent the shapes from intersecting with each other. This is an important distinction in collision detection algorithms, and it is usually known as a collision response. Collision responses and how to do them is a whole different problem from simply detecting whether or not two shapes collide with one another!

## Adding a Collision Response

Luckily for us, SAT is relatively easy to adapt to give a collision response – namely, if you find that all shadows (and therefore the shapes) overlap, you can find the pair of shadows that overlaps the least, and push the two shapes apart in that direction until the shadows don't touch anymore! Let's see how we could implement that idea in code as well: 



For now, this is it, with something like the above, you could have collision detection of arbitrary shapes, by carving them up into neat little triangles and then running collision detection on those. You could even constrain and stop the shapes from moving into each other by adding a collision response. However... Collision detection is a tricky business and there are still edge cases where the above breaks down. The first would be objects that move very very quickly. If they move quickly enough they could simply pass through other objects. In games, usually bullets would show this kind of behavior. The other problem is that of having lots of shapes. We only checked if two polygons were colliding with each other... what about 10, 100, 1000? These kinds of collision detection algorithms are expensive and if we have to check every single polygon against every single other polygon the amount of computations we have to do grows with O(n²) complexity which is really not good. Which means we would need to use yet more tricks to divide up shapes spatially. Because two shapes which are very very far apart can not intersect (unless one of them is really really big) therefore we could cut down on the number of collision detections we actually have to do by a whole lot. The general idea algorithm that would be used for that is called a Quadtree (in 2D) or and Octtree  (in 3d). But coding these is reserved for Part II of this article!

