---
title: "SAT Collision Detection"
subtitle: "An explanation of the Separating Axis Theorem"
excerpt: 'Have you ever played a computer game and started asking yourself... Wait a second, how does the computer actually know how to stop moving my character when I hit the ground? Or when I run into an obstacle? It is quite awesome that all of this "just" works... but how exactly does the computer do it?'
cover: "/assets/blog/sat.png"
date: "2022-10-13"
author:
  name: Rico Trebeljahr
  picture: "/assets/blog/profile.jpeg"

---

<p>{excerpt}</p>

This post is going to answer that question, by explaining one particular algorithm that can be used to tackle this sort of problem. 

In all the demos below, you can drag around the polygons (and the points), as well as rotate the polygons around their centers by pressing the A or D keys! 

<SATWithResponse drawProjections={false} responseToggle={false}/>

What you see in the demo above is based on a mathematical idea known as the "Separating Axis Theorem". We'll derive this idea and how it can be used for collision detections, in code, step by step. 

The main idea behind this theorem is simple. 

>  If you can draw a line *between* two shapes, without touching either of them, then the two shapes do *not* collide. 

If you can find such a line, you know for sure, that the two shapes are separated from each other by that line! And that's why this line is called a "separating axis", and hence the name of the theorem: "Separating Axis Theorem". But how does the computer search for these lines that separate two shapes? 

It's using shadows!

## Shadows?

In linear algebra a projection is essentially what happens if you were to shine a light onto an object from very, very far away. The object would cast a shadow onto the wall and this shadow on the wall is what is mathematically known as a "projection".

The demo's of this article will only be in two dimensions and hence the "wall" becomes a simple line and the object becomes a single point.

But the idea, of shining a light onto that point and tracking where the shadow will fall on the line stays exactly the same. For the next section you should be comfortable with some basic concepts of vectors and "linear algebra", if you aren't [here's a quick overview of the concepts necessary](/posts/vectors-101).


## Projections

In case you had to refresh your knowledge on vectors â€“ welcome back! Now that these basic ideas are out of the way, let's tackle casting some shadows! 

Luckily there is a mathematical expression for how to calculate a shadow that a point would cast onto a line! 

Given the Points a, b, and c, where c is the point we want to project and a and b are the two points defining the line $\overline{ab}$, we can find the projection of c onto the line $\overline{ab}$ it: 

$$
p = c - a
$$
$$
q = b - a
$$
$$
proj_c \, q = \frac{a + p \, \cdotp	q}{\lVert q \rVert^2}* q
$$

The same formula can be expressed in code:

```typescript
function projectOnLine(a: Vector2, b: Vector2, c: Vector2) {
    const p = c.sub(a);
    const q = b.sub(a);
    return a.add(q.multScalar(p.dot(q) / q.mag2()));
}
```

Drawing this out onto the canvas yields a line going through a and b and an arrow p, going from a to c, which casts a shadow on the line from b to a! There's a demo below, where you can try dragging around the points A, B, and C to change the direction, position and length of the vector and the line. For all the demos in the rest of this article, you should be able to drag around the shapes themselves as well as the points making up the shapes. You can also click on shapes to "select" them and then rotate them by holding down the A and D keys on your keyboard! 

<MatrixDemo />

In a way the above can be done for any 2 vectors. For a line, we needed 2 points to get the direction of the line *and* to shift the result onto the line by adding on the vector/point a!
The whole idea for only two vectors can be expressed more shortly and is also a useful operation to have in general. 
$$
proj_b \, a = \frac{a \, \cdotp b}{\lVert b \rVert^2} * b
$$

The same idea in Typescript:
```typescript
function project(a: Vector2, b: Vector2) {
  return b.multScalar(a.dot(b) / b.mag2());
}
```

There is also the idea of using a "scalar" projection. A scalar is "just" a number, and the result of scalar projections are just numbers. A scalar projection calculates the length of the projection of vector a in the direction of vector b. And it can be computed like so:
$$
s = \lVert a \rVert	* cos(\theta) = a \, \cdotp \hat{b}
$$
Notice the little hat on the b, that means that this is [a unit vector](/posts/vectors-101)!




## Projecting a Whole Polygon

The main idea for the SAT algorithm, is that these projections of points can become very useful, because they can help determine whether or not a single ray of light could shine through in between two polygons. 

The cool thing is, if there *could* be a light ray between two polygons, that means that they can not intersect! 

Otherwise, how could the light get through?

This means, that if there is light between the shadows of two polygons, there also has to be a separating axis (the ray of light itself!) and we can safely say that the two polygons don't touch each other! Because we can shine a light through in between them. 

So the goal now is this: find two shadows (projections) that don't overlap for the two polygons. If all the shadows overlap, then the two polygons will overlap.

However to get there, we first need to be able to project a whole polygon onto a line. Casting the shadow for a whole object, not just for a single point... 

Luckily, a polygon is just a set of points. Usually the points of a polygon are called vertices in computer graphics. The singular vertices is vertex. 

If we were to simply project all the vertices of a polygon we would still have to figure out which points are the "left" and "right" edge of the shadow.

There are multiple approaches to do this, but one I find particularly fascinating and which is the one used down below in the demos is that of using a support function. 

Essentially a support function finds a point among a set of points (here the vertices of the polygon we want to project), that is furthest along in a particular direction. 

The trick here is to run the polygon through the finding of support points for the two different directions of the line, which will result in the two points furthest along these directions. In the code below for the getting the support point in a specific direction notice, how we use the dot product to keep track of the distance for the scalar projections between of the vertex onto b?

```js
export function getSupportPoint(vertices: Vector2[], d: Vector2) {
  // initialize variables
  let highest = -Infinity;
  let support = new Vector2(0, 0);
  
  // loop over the vertices of the polygon
  for (let vertex of vertices) {
    // compute the dot product between the vertex and the direction
    const dot = vertex.dot(d);
	
    // keep track of the highest dot product and thereby the furthest point along the direction
    if (dot > highest) {
      highest = dot;
      support = vertex;
    }
  }
  
  // return the point with the highest dot product with the direction!
  return support;
}
```

We can then use these support points to project them onto the line for creating the "left" and "right" edge of the shadow.

```typescript
export function drawProjection(
  ctx: CanvasRenderingContext2D,
  polys: Polygon | [Polygon, Polygon],
  p1: Vector2,
  p2: Vector2
) {
 

  // get directions for "up" and "down" the line
  const d2 = p2.sub(p1);
  const d1 = p1.sub(p2);

  // create translation matrix
  const origin = new Vector2(parseFloat(ctx.canvas.style.width) / 2, parseFloat(ctx.canvas.style.height) / 2);
  const toOrigin = getTranslationMatrix(origin.x, origin.y);
 
  // use translation matrix + scaling to create far apart line points
  // which goes through origin in the middle of the canvas 
  const len = Math.max(parseFloat(ctx.canvas.style.width), parseFloat(ctx.canvas.style.height));
  const l1 = d2.unit().multScalar(len).transform(toOrigin);
  const l2 = d2.unit().multScalar(-len).transform(toOrigin);

  // draw line onto which should be projected
  ctx.strokeStyle = "rgba(100, 100, 100, 0.5)";
  line(ctx, l2, l1);
  
  // get support points for each direction
  const s1 = getSupportPoint(poly.vertices, d1);
  const s2 = getSupportPoint(poly.vertices, d2);
  
  // get projection for each support point
  const projectedS1 = projectOnLine(l1, l2, s1);
  const projectedS2 = projectOnLine(l1, l2, s2);
  
  // draw shadow based on projections
  line(ctx, projectedS1, projectedS2);

  // also draw a dashed line between the projected and support points
  ctx.save();
  ctx.setLineDash([5, 15]);
  ctx.strokeStyle = "rgb(150, 150, 150)";
  line(ctx, s1, projectedS1);
  line(ctx, s2, projectedS2);
  ctx.restore();
}
```

<ProjectionDemo />

## Projection for 2 Polygons 

All of this also works for 2 Polygons at once of course! The question we would like to answer given the two shadows is whether or not they overlap. Since the shadows are two line segments, that we know to be collinear we can use a simple test like the one below to check whether or not they overlap. 

```typescript
function onSegment(p: Vector2, q: Vector2, r: Vector2) {
  if (
    q.x <= Math.max(p.x, r.x) &&
    q.x >= Math.min(p.x, r.x) &&
    q.y <= Math.max(p.y, r.y) &&
    q.y >= Math.min(p.y, r.y)
  )
    return true;

  return false;
}

function doIntersect(a1: Vector2, a2: Vector2, b1: Vector2, b2: Vector2) {
  if (onSegment(a1, b1, a2)) return true;
  if (onSegment(a1, b2, a2)) return true;
  if (onSegment(b1, a1, b2)) return true;
  if (onSegment(b1, a2, b2)) return true;

  return false;
}
```

There are also versions of this test, which use the dot product to determine how far along the line the points are and by comparing the minimum and maximum against each other determine whether or not they overlap. Which algorithm we use doesn't matter so much in the end, the important thing is that we can test for the two shadows "overlapping" or not. In the example below, if the shadows overlap we change the color to red.

<ExampleWith2Polygons />

## The Last Idea

How should we pick the lines that we project onto? Isn't there an infinity of possible lines we could chose from? 

Luckily for us, there is a last insight for the SAT algorithm to work, namely that we only have to check a single axis for every edge of the polygons we want to check for collisions. 
Namely, need to check each of the normals of the edges, and see if the shadows projected onto that normal overlap. You can see that in the example below, where we are slowly cycling through the different normals, one by one! 

The only thing we are interested in from the normal is the direction, so we displace it towards the origin and draw a line passing in the same general direction that the normal was pointing in. Usually normals would be directly on the edge of the polygon. 

The edge to which the normal belongs to is colored yellow in the example and you can see how the line drawn through the origin is always perpendicular to the yellow edge (because the direction is taken from the normal that has to be the case)!

<AxisByAxis />

In the above example, if you make the shapes overlap, what do you notice about their shadows?

## Complete SAT

The loop we did, step by step with a delay above was just for visualization purposes, instead we can just check all of the normals at once and see: if all shadows overlap (and show up in red), then the shapes also have to overlap too and we can color them red! That's the whole meaning behind the separating axis theorem.

<SAT/>

This is all there is to a simple SAT collision detection algorithm. To sum up the algorithm: Cast shadows (projections) onto the normals of two polygons and check if the projections overlap. If you find a pair of projections that doesn't overlap, there is no collision. If all projections overlap, there is a collision.

Now you might say, wait a second... we don't yet prevent the shapes from intersecting with each other, do we? 

And you would be right. 

This is an important distinction in collision detection algorithms, between calculating *if* two shapes collide, and then *what to do* to deal with that collision. 

This second problem is usually known as calculating a collision response. So, how could we appropriately respond to the collision? 

## Adding a Collision Response

Luckily for us, SAT is relatively easy to adapt to give a collision response â€“ namely, if you find that all shadows (and therefore the shapes) overlap, you can find the pair of shadows that overlaps the least, and push the two shapes apart in that direction until the shadows don't touch anymore! 

This idea of the "overlap" between the two shadows is related to an idea known as the MTV â€“ the Minimum Translation Vector. In a way the smallest overlap of the shadows of the two polygons projected onto their normals is a vector that tells us exactly how far and in which direction the two shapes have to move so that at least one pair of shadows stops overlapping. It represents the minimum amount of work necessary to push the shapes apart. So we just apply half of the vector as a translation transformation to one shape and the opposite of that to the other shape. 

Let's see how we could implement that idea in code:

```typescript
function getShadowOverlap(
  axis: Vector2,
  pointsA: Vector2[],
  pointsB: Vector2[]
) {
  const rangeA = flattenPointsOn(pointsA, axis);
  const rangeB = flattenPointsOn(pointsB, axis);

  let overlap = 0;
  if (rangeA.min < rangeB.min) {
    if (rangeA.max < rangeB.max) {
      overlap = rangeA.max - rangeB.min;
    } else {
      const option1 = rangeA.max - rangeB.min;
      const option2 = rangeB.max - rangeA.min;
      overlap = option1 < option2 ? option1 : -option2;
    }
  } else {
    if (rangeA.max > rangeB.max) {
      overlap = rangeA.min - rangeB.max;
    } else {
      const option1 = rangeA.max - rangeB.min;
      const option2 = rangeB.max - rangeA.min;
      overlap = option1 < option2 ? option1 : -option2;
    }
  }

  return overlap;
}

export function getResponseForCollision(poly1: Polygon, poly2: Polygon) {
  let smallestOverlap = Infinity;
  let axis = new Vector2(0, 0);
  // loop over all the polygon normals
  for (let normal of [...poly1.edgeNormals(), ...poly2.edgeNormals()]) {
    // get the overlap between the shadows
    const overlap = getShadowOverlap(normal, poly1.vertices, poly2.vertices);
    const absOverlap = Math.abs(overlap);
    // check if overlap is smallest so far
    if (absOverlap < Math.abs(smallestOverlap)) {
      smallestOverlap = overlap;
      axis = normal.copy();
      if (overlap < 0) {
        axis.multScalar(-1);
      }
    }
  }

  return axis.transform(getScalingMatrix(smallestOverlap, smallestOverlap));
}
```

Then we can use that getResponseForCollision function like so: 

```typescript
// get MTV
const responseVector = getResponseForCollision(poly1, poly2);
// scale MTV by 0.51 or -0.51 respectively.
const half = responseVector.multScalar(0.51);
const halfNeg = responseVector.multScalar(-0.51);
if (response) {
  // if response should happen, translate polygons by MTVs
  poly1.translate(halfNeg);
  poly2.translate(half);
} else {
  // if response should not happen â€“ draw the MTV arrows
  drawArrow(ctx, poly1.centroid(), poly1.centroid().add(halfNeg));
  drawArrow(ctx, poly2.centroid(), poly2.centroid().add(half));
}
``` 

And here is the demo:

<SATWithResponse />

Cool, so we are done now, right? Well, check this out: 

<SATWithConcaveShapes />

## The Problem of Concavity

Well... that didn't go to well huh? The problem is that what you just saw were so called "concave" shapes... All the polygons you've seen so far up to this point were "convex", and I took some precautions so that this is always the case.

Convex and concave are just two words to express that something bulges outwards or inwards. I remember them with the word "cave" as in con*cave*. A cave goes inward, so does a concave object. In other words, concave shapes are shapes that have some kind of indentation in them. A star would be a concave shape, or a something like a V etc. To handle collisions with concave shapes is very tricky... And usually people don't bother and just chop their concave shapes up into simpler, convex shapes and then run collision detection algorithms on them. 

Mostly people chop them up into triangles using a process called triangulation (which has many different algorithms for it...) So let's look at some.

## Triangulating Concave Shapes

<Triangulation />


For now, this is it, with something like the above, you could have collision detection of arbitrary shapes, by carving them up into neat little triangles and then running collision detection on those. You could even constrain and stop the shapes from moving into each other by adding a collision response. 

However... Collision detection is a tricky business and there are still edge cases where the above breaks down. 

The first would be objects that move very very quickly. If they move quickly enough they could simply pass through other objects. In games, usually bullets would show this kind of behavior. 

The other problem is that of having lots of shapes. We only checked if two polygons were colliding with each other... what about 10, 100, 1000? These kinds of collision detection algorithms are expensive and if we have to check every single polygon against every single other polygon the amount of computations we have to do grows with O(nÂ²) complexity which is really not good. 

Which means we would need to use yet more tricks to divide up shapes spatially. Because two shapes which are very very far apart can not intersect (unless one of them is really really big) therefore we could cut down on the number of collision detections we actually have to do by a whole lot. The general idea algorithm that would be used for that is called a Quadtree (in 2D) or and Octree (in 3d). 

![octree visualization](/assets/blog/octree.png)

But coding these is reserved for Part II of this article!

