---
title: "Vectors 101"
subtitle: "A practical intro to Vector Mathematics"
excerpt: 'This post is an exploration of many different and important vector concepts and how they can be implemented in code. After reading it you should walk away with an understanding of how and why these operations work and where they could be useful.'
cover: "/assets/blog/vector-demo.png"
date: "2022-10-13"
author:
  name: Rico Trebeljahr
  picture: "/assets/blog/profile.jpeg"

---

<p>{excerpt}</p>

## The Confusion between Points and Vectors

Points can be modeled with vectors, you can think of the vectors as little arrows pointing to a location somewhere in space. 

In mathematics vectors are often noted down as variables, like this $\overrightharpoon v$ or this $\overrightarrow v$ or this $v$.

But vectors are made up out of components so they can also be written like this:

$$
\begin{bmatrix}
   x \\
   y
\end{bmatrix}
or 
\begin{bmatrix}
   2 \\
   5
\end{bmatrix}
or
\begin{bmatrix}
   -1 \\
   20
\end{bmatrix}
or 
\begin{bmatrix}
   a \\
   b
\end{bmatrix}
$$

A component is a part of a vector that points into a certain direction. These directions depend on the coordinate system. Usually the vector components mean distance in the x – the horizontal direction and y – the vertical direction.

Thinking of vectors in components in that way is very useful since we can see the amount that the vector goes into each of the directions x and y, at a glance. It's like saying, go x steps along this direction, then turn 90° and go y steps this way and voila, you reached the correct place I wanted you to go to. This is what makes vectors so highly useful, it's a way of describing coordinates, positions and directions with mathematics!

So a vector can be a point and a direction. Hence the idea of the little arrow in the notation $\hat{v}$ – the arrow/the vector is "pointing" into a direction in space, just like an arrow does!

A straight line can be defined by two points (or two vectors). Please try dragging around the points in the demo below to move the lines and the arrows around!

<PointAndLineDemo/>

The direction of the line can be calculated by getting the difference between two of the points it is passing through. Each line has two directions – depending on the order of subtraction of the points. If you subtract A from B you get one direction and B from A gives you the other. The only difference between the two directions are the signs in front of the vector components, flip both signs and you would get the "opposite" direction. 

## Subtraction, Addition, Multiplication and Division of Vectors

All of these are easy to do for vectors! Since vectors are just made up of components, to calculate with them, you simply add, subtract, multiply or divide on all the components simultaneously. 
$$
\overrightharpoon{v} * a = 
\begin{bmatrix}
x * a \\
y * a
\end{bmatrix}
$$

However what happens if you want to calculate with two vectors at once? 
$$
v * a = 
\begin{bmatrix}
x * a \\
y * a
\end{bmatrix}
$$

## Magnitude, Norm and length

The magnitude or norm is just mathematical jargon for "the length" of a vector. 

If you imagine that a vector is giving you a location in space you could say, hmmm, if I were to walk there, how long would I have to walk? The answer to that can be found out by using the Pythagorean theorem. 

Think of the x and y components and how they form the two sides of a right angled triangle and how the hypotenuse of that triangle is the vector (and the length) we are interested in. Hence the formula for the length of a vector is simply the Pythagorean theorem. 

$$
\lVert
  v 
\rVert = \sqrt{x² + y²} = v \, \cdotp v
$$

<MagnitudeDemo/>

Sometimes we don't need the actual length but the squared length, and so we can drop the $\sqrt{}$ from the formula above. If we implement these two ideas mag and mag2 (squared norm/length) ideas in code, we get the below. 
```typescript
function mag2(v: Vec2) {
  return dot(v, v);
}

function mag(v: Vec2) {
  return Math.sqrt(mag2(v));
}
```

It's often useful to have the mag2 version because taking the square root is an expensive operation and for some applications we don't actually need the "correct" length of the vector, because the squared length suffices. 

Hence you can also find both methods on the Vec2 implementation!

## Unit Vectors

The norm or magnitude of a vector is also often used to construct a "unit" vector. 

Unit vectors are "raw" directions. You get them if you divide the vector by it's norm you get a vector of length 1. But you are preserving the direction of the vector!
And the name stems from the "unit" circle, a circle of a radius of length 1. Just like the radius of the circle, unit vectors have a length of 1. 
$$
\hat{v} = \frac{v}{\lVert v \rVert} 
$$

In code this would look something like this:
```typescript
function unit(b: Vec2) {
  return b.divScalar(b.mag());
}
```

Here's a demo, the green circle is the "unit circle", it has a radius of exactly 1 unit. See how the black vector always follows the blue one, yet stays exactly on the edge of the circle? That's what it means to normalize a vector/create a unit vector.

<UnitVectorDemo />

## The "Perp" or Perpendicular 

In 2D getting a vector rotated by exactly 90° is very easy! You can simply swap the x and y components, and then negate the swapped x!
$$
\begin{bmatrix}
x \\
y 
\end{bmatrix}

\xrightarrow[\circlearrowright]{\, \, 90°}

\begin{bmatrix}
y \\
-x 
\end{bmatrix}
$$

The reason for this has to do with the trigonometric functions sin and cos – and how they relate angles and vectors. All of this can be combined with rotational matrices and is used a lot in computer graphics!

```typescript
function perp(v: Vec2) {
  return new Vec2(v.y, -v.x);
}
```

## The Dot Product

The dot product of a vector is defined as adding up the multiples of it's components. Vectors can have multiple components, x,y,z etc. based on how many dimensions of space the vector is in, but for this article we keep everything simple, and only worry about vectors in 2D. Those only have 2 components: x and y. It  can be computed like this:
$$
v \, \cdotp a = x_a * x_v + y_a * y_v
$$

Or in code: 

```typescript
function dot(v: Vec2) {
  return v.x * v.x + v.y * v.y
}
```
Dot Products are extremely useful in mathematics and computer graphics for multiple reasons – they are related to the angles between vectors. The formula for the angle $\theta$ between two vectors is this:
$$
\theta = \frac{v \, \cdotp a}{\lVert v \rVert * \lVert a \rVert}
$$


<DotProductDemo />

## Normals

The concept of a normal is very very useful in computer graphics and linear algebra. The main idea of a normal is a vector that is perpendicular (at 90°) to another vector (or line/edge). Usually each line has two normals – one in each direction, however when working with polygons one is usually interested in the normals facing out of the polygon, not the ones facing into the polygon. 
The idea of normals is heavily related to the perpendiculars that we already wrote, essentially the perpendicular to a vector is also the normal to it. 

<NormalDemo/>

In a lot of computer graphics applications bugs can happen where the normals get inverted for some reason, like a faulty import of a model from a different program. 

Usually when this happens it messes up the lighting calculations, because the shape is "wrapped" into the wrong direction and light that should bounce "away" from the shape, bounces "into" the shape instead...


## Summary
As we have seen, there are a lot of fancy things that can be done with vectors, even just in 2D, so let's write a class that implements all of those functionalities and methods from above and use that for demos such as the SAT or GJK algorithms!

```typescript
const precision = 0.000001;
export class Vec2 {
  public components: [number, number];

  constructor(x: number, y: number) {
    this.components = [x, y];
  }

  get x() {
    return this.components[0];
  }
  set x(newX: number) {
    this.components[0] = newX;
  }
  get y() {
    return this.components[1];
  }
  set y(newY: number) {
    this.components[1] = newY;
  }

  mag() {
    return Math.sqrt(this.mag2());
  }

  mag2() {
    return this.dot(this);
  }

  divScalar(scalar: number) {
    return new Vec2(this.x / scalar, this.y / scalar);
  }

  multScalar(scalar: number) {
    return new Vec2(this.x * scalar, this.y * scalar);
  }

  sub(other: Vec2) {
    return new Vec2(this.x - other.x, this.y - other.y);
  }

  add(other: Vec2) {
    return new Vec2(this.x + other.x, this.y + other.y);
  }

  unit() {
    return this.divScalar(this.mag());
  }

  perp() {
    return new Vec2(this.y, -this.x);
  }

  getNormal() {
    return this.perp().unit();
  }

  dot(other: Vec2) {
    return this.x * other.x + this.y * other.y;
  }

  copy() {
    return new Vec2(this.x, this.y);
  }

  equals(other: Vec2) {
    return (
      Math.abs(other.x - this.x) < precision &&
      Math.abs(other.y - this.y) < precision
    );
  }

  perpDot(other: Vec2) {
    return this.perp().dot(other);
  }
}
```