---
title: "SAT Collision Detection"
subtitle: "An explanation of the Separating Axis Theorem"
excerpt: 'Have you ever played a computer game and started asking yourself... Wait a second, how does the computer actually know how to stop moving my character when I hit the ground? Or when I run into an obstacle? It is quite awesome that all of this "just" works... but how exactly does the computer do it?'
cover: "/assets/blog/sat.png"
date: "2022-10-13"
author:
  name: Rico Trebeljahr
  picture: "/assets/blog/profile.jpeg"

---

<p>{excerpt}</p>

This post is going to answer that question, by explaining one particular algorithm that can be used to tackle this sort of problem – the SAT Algorithm. 

In all the demos of this article, you can drag around the polygons (and their points), as well as rotate polygons around their centers by pressing the A or D keys! 

<Triangulation drawTris={false} responseToggle={false}/>

What you see in the demo above is based on the SAT (Separating Axis Theorem) Algorithm. We'll derive this idea and how it can be used for collision detections, with mathematics and in code, step by step. 

The main idea behind it is simple. 

>  If you can draw a line *between* two shapes, without touching either of them, then the two shapes do *not* collide. 

If you can find such a line, you know for sure, that the two shapes are separated from each other by that line! And that's why this line can be called a "separating axis", and that's exactly where the name of the theorem comes from. 

But how does the computer search for the lines that separate two shapes? 
It's using shadows!

## Shadows?

In linear algebra a projection is essentially what happens if you were to shine a light onto an object from very, very far away. The object would cast a shadow onto the wall and this shadow on the wall is what is mathematically known as a "projection". You could also think of it as "flattening" the shape with a giant press that is aligned with the line.

The demo's of this article will only be in two dimensions and hence the "wall" becomes a simple line and the object becomes a single point.

But the idea, of shining a light onto that point and tracking where the shadow will fall on the line (or flattening the object onto the line) stays exactly the same. For the next section you should be comfortable with some basic concepts of vectors and "linear algebra", if you aren't [here's a quick summary of the concepts necessary](/posts/vectors-101).


## Projections

In case you had to refresh your knowledge on vectors – welcome back! Now that these basic ideas are out of the way, let's tackle casting some shadows! 

Luckily there is a mathematical expression for how to calculate a shadow that a point would cast onto a line! 

Given the Points a, b, and c, where c is the point we want to project and a and b are the two points defining the line $\overline{ab}$, we can find the projection of c onto the line $\overline{ab}$ like so: 

$$
p = c - a
$$
$$
q = b - a
$$
$$
proj_c \, q = \frac{a + p \, \cdotp	q}{\lVert q \rVert^2}* q
$$

The same formula can be expressed in code:

```typescript
function projectOnLine(a: Vec2, b: Vec2, c: Vec2) {
    const p = c.sub(a);
    const q = b.sub(a);
    return a.add(q.multScalar(p.dot(q) / q.mag2()));
}
```

Drawing this out onto the canvas yields a line going through a and b and an arrow p, going from a to c, which casts a shadow on the line from b to a! There's a demo below, where you can try dragging around the points A, B, and C to change the direction, position and length of the vector and the line. For all the demos in the rest of this article, you should be able to drag around the shapes themselves as well as the points making up the shapes. You can also click on shapes to "select" them and then rotate them by holding down the A and D keys on your keyboard! 

<MatrixDemo />

In a way the above can be done for any 2 vectors. For a line, we needed 2 points to get the direction of the line *and* to shift the result onto the line by adding on the vector/point a!
The whole idea for only two vectors can be expressed more shortly and is also a useful operation to have in general. 
$$
proj_b \, a = \frac{a \, \cdotp b}{\lVert b \rVert^2} * b
$$

The same idea in Typescript:
```typescript
function project(a: Vec2, b: Vec2) {
  return b.multScalar(a.dot(b) / b.mag2());
}
```

There is also the idea of using a "scalar" projection. A scalar is "just" a number, and the result of scalar projections are just numbers. A scalar projection calculates the length of the projection of vector a in the direction of vector b. And it can be computed like so:
$$
s = \lVert a \rVert	* cos(\theta) = a \, \cdotp \hat{b}
$$
Notice the little hat on the b, that means that this is [a unit vector](/posts/vectors-101)!




## Projecting a Whole Polygon

The main idea for the SAT algorithm, is that these projections of points can become very useful, because they can help determine whether or not a single ray of light could shine through in between two polygons. 

The cool thing is, if there *could* be a light ray between two polygons, that means that they can not intersect! 

Otherwise, how could the light get through?

This means, that if there is light between the shadows of two polygons, there also has to be a separating axis (the ray of light itself!) and we can safely say that the two polygons don't touch each other! Because we can shine a light through in between them. 

So the goal now is this: find two shadows (projections) that don't overlap for the two polygons. If all the shadows overlap, then the two polygons will overlap.

However to get there, we first need to be able to project a whole polygon onto a line. Casting the shadow for a whole object, not just for a single point... 

Luckily, a polygon is just a set of points. Usually the points of a polygon are called vertices in computer graphics. The singular vertices is vertex. If we were to simply project all the vertices of a polygon we would still have to figure out which points are the "left" and "right" edge of the shadow.

There are multiple approaches to do this, but one I find particularly fascinating and which is the one used down below in the demos is that of using a support function. 

Essentially a support function finds a point among a set of points (here the vertices of the polygon we want to project), that is furthest along in a particular direction. 

The trick here is to run the polygon through the finding of support points for the two different directions of the line, which will result in the two points furthest along these directions. In the code below for the getting the support point in a specific direction notice, how we use the dot product to keep track of the distance for the scalar projections between of the vertex onto b?

```js
export function getSupportPoint(vertices: Vec2[], d: Vec2) {
  // initialize variables
  let highest = -Infinity;
  let support = new Vec2(0, 0);
  
  // loop over the vertices of the polygon
  for (let vertex of vertices) {
    // compute the dot product between the vertex and the direction
    const dot = vertex.dot(d);
	
    // keep track of the highest dot product and thereby the furthest point along the direction
    if (dot > highest) {
      highest = dot;
      support = vertex;
    }
  }
  
  // return the point with the highest dot product with the direction!
  return support;
}
```

We can then use these support points to project them onto the line for creating the "left" and "right" edge of the shadow.

```typescript
export function drawProjection(
  ctx: CanvasRenderingContext2D,
  polys: Polygon | [Polygon, Polygon],
  p1: Vec2,
  p2: Vec2
) {
 

  // get directions for "up" and "down" the line
  const d2 = p2.sub(p1);
  const d1 = p1.sub(p2);

  // create translation matrix
  const origin = new Vec2(parseFloat(ctx.canvas.style.width) / 2, parseFloat(ctx.canvas.style.height) / 2);
  const toOrigin = getTranslationMatrix(origin.x, origin.y);
 
  // use translation matrix + scaling to create far apart line points
  // which goes through origin in the middle of the canvas 
  const len = Math.max(parseFloat(ctx.canvas.style.width), parseFloat(ctx.canvas.style.height));
  const l1 = d2.unit().multScalar(len).transform(toOrigin);
  const l2 = d2.unit().multScalar(-len).transform(toOrigin);

  // draw line onto which should be projected
  ctx.strokeStyle = "rgba(100, 100, 100, 0.5)";
  line(ctx, l2, l1);
  
  // get support points for each direction
  const s1 = getSupportPoint(poly.vertices, d1);
  const s2 = getSupportPoint(poly.vertices, d2);
  
  // get projection for each support point
  const projectedS1 = projectOnLine(l1, l2, s1);
  const projectedS2 = projectOnLine(l1, l2, s2);
  
  // draw shadow based on projections
  line(ctx, projectedS1, projectedS2);

  // also draw a dashed line between the projected and support points
  ctx.save();
  ctx.setLineDash([5, 15]);
  ctx.strokeStyle = "rgb(150, 150, 150)";
  line(ctx, s1, projectedS1);
  line(ctx, s2, projectedS2);
  ctx.restore();
}
```

<ProjectionDemo />

## Projection for 2 Polygons 

All of this also works for 2 Polygons at once of course! The question we would like to answer given the two shadows is whether or not they overlap. Since the shadows are two line segments, that we know to be collinear we can use a simple test like the one below to check whether or not they overlap. 

```typescript
function onSegment(p: Vec2, q: Vec2, r: Vec2) {
  if (
    q.x <= Math.max(p.x, r.x) &&
    q.x >= Math.min(p.x, r.x) &&
    q.y <= Math.max(p.y, r.y) &&
    q.y >= Math.min(p.y, r.y)
  )
    return true;

  return false;
}

function doIntersect(a1: Vec2, a2: Vec2, b1: Vec2, b2: Vec2) {
  if (onSegment(a1, b1, a2)) return true;
  if (onSegment(a1, b2, a2)) return true;
  if (onSegment(b1, a1, b2)) return true;
  if (onSegment(b1, a2, b2)) return true;

  return false;
}
```

There are also versions of this test, which use the dot product to determine how far along the line the points are and by comparing the minimum and maximum against each other determine whether or not they overlap. Which algorithm we use doesn't matter so much in the end, the important thing is that we can test for the two shadows "overlapping" or not. In the example below, if the shadows overlap we change the color to red.

<ExampleWith2Polygons />

## The Last Idea

How should we pick the lines that we project onto? Isn't there an infinity of possible lines we could chose from? 

Luckily for us, there is a last insight for the SAT algorithm to work, namely that we only have to check a single axis for every edge of the polygons we want to check for collisions. 
Namely, need to check each of the normals of the edges, and see if the shadows projected onto that normal overlap. You can see that in the example below, where we are slowly cycling through the different normals, one by one! 

The only thing we are interested in from the normal is the direction, so we displace it towards the origin and draw a line passing in the same general direction that the normal was pointing in. Usually normals would be directly on the edge of the polygon. 

The edge to which the normal belongs to is colored yellow in the example and you can see how the line drawn through the origin is always perpendicular to the yellow edge (because the direction is taken from the normal that has to be the case)!

<AxisByAxis />

In the above example, if you make the shapes overlap, what do you notice about their shadows?

## Complete SAT

The loop we did, step by step with a delay above was just for visualization purposes, instead we can just check all of the normals at once and see: if all shadows overlap (and show up in red), then the shapes also have to overlap too and we can color them red! That's the whole meaning behind the separating axis theorem.

<SAT/>

This is all there is to a simple SAT collision detection algorithm. To sum up the algorithm: Cast shadows (projections) onto the normals of two polygons and check if the projections overlap. If you find a pair of projections that doesn't overlap, there is no collision. If all projections overlap, there is a collision.

Now you might say, wait a second... we don't yet prevent the shapes from intersecting with each other, do we? 

And you would be right. 

This is an important distinction in collision detection algorithms, between calculating *if* two shapes collide, and then *what to do* to deal with that collision. 

This second problem is usually known as calculating a collision response. So, how could we appropriately respond to the collision? 

## Adding a Collision Response

Luckily for us, SAT is relatively easy to adapt to give a collision response – namely, if you find that all shadows (and therefore the shapes) overlap, you can find the pair of shadows that overlaps the least, and push the two shapes apart in that direction until the shadows don't touch anymore! 

This idea of the "overlap" between the two shadows is related to an idea known as the MTV – the Minimum Translation Vector. In a way the smallest overlap of the shadows of the two polygons projected onto their normals is a vector that tells us exactly how far and in which direction the two shapes have to move so that at least one pair of shadows stops overlapping. It represents the minimum amount of work necessary to push the shapes apart. So we just apply half of the vector as a translation transformation to one shape and the opposite of that to the other shape. 

Let's see how we could implement that idea in code:

```typescript
function getShadowOverlap(
  axis: Vec2,
  pointsA: Vec2[],
  pointsB: Vec2[]
) {
  const rangeA = flattenPointsOn(pointsA, axis);
  const rangeB = flattenPointsOn(pointsB, axis);

  let overlap = 0;
  if (rangeA.min < rangeB.min) {
    if (rangeA.max < rangeB.max) {
      overlap = rangeA.max - rangeB.min;
    } else {
      const option1 = rangeA.max - rangeB.min;
      const option2 = rangeB.max - rangeA.min;
      overlap = option1 < option2 ? option1 : -option2;
    }
  } else {
    if (rangeA.max > rangeB.max) {
      overlap = rangeA.min - rangeB.max;
    } else {
      const option1 = rangeA.max - rangeB.min;
      const option2 = rangeB.max - rangeA.min;
      overlap = option1 < option2 ? option1 : -option2;
    }
  }

  return overlap;
}

export function getResponseForCollision(poly1: Polygon, poly2: Polygon) {
  let smallestOverlap = Infinity;
  let axis = new Vec2(0, 0);
  // loop over all the polygon normals
  for (let normal of [...poly1.edgeNormals(), ...poly2.edgeNormals()]) {
    // get the overlap between the shadows
    const overlap = getShadowOverlap(normal, poly1.vertices, poly2.vertices);
    const absOverlap = Math.abs(overlap);
    // check if overlap is smallest so far
    if (absOverlap < Math.abs(smallestOverlap)) {
      smallestOverlap = overlap;
      axis = normal.copy();
      if (overlap < 0) {
        axis.multScalar(-1);
      }
    }
  }

  return axis.transform(getScalingMatrix(smallestOverlap, smallestOverlap));
}
```

Then we can use that getResponseForCollision function like so: 

```typescript
// get MTV
const responseVector = getResponseForCollision(poly1, poly2);
// scale MTV by 0.51 or -0.51 respectively.
const half = responseVector.multScalar(0.51);
const halfNeg = responseVector.multScalar(-0.51);
if (response) {
  // if response should happen, translate polygons by MTVs
  poly1.translate(halfNeg);
  poly2.translate(half);
} else {
  // if response should not happen – draw the MTV arrows
  drawArrow(ctx, poly1.centroid(), poly1.centroid().add(halfNeg));
  drawArrow(ctx, poly2.centroid(), poly2.centroid().add(half));
}
```

And here is the demo:

<SATWithResponse />

Cool, so we are done now, right? Well, check this out: 

<SATWithConcaveShapes />

## The Problem of Concavity

Well... that didn't go to well huh? The problem is that what you just saw were so called "concave" shapes... All the polygons you've seen so far up to this point were "convex", and I took some precautions so that this is always the case.

Convex and concave are just two words to express that something bulges outwards or inwards. I remember them with the word "cave" as in con*cave*. A cave goes inward, so does a concave object. In other words, concave shapes are shapes that have some kind of indentation in them. A star would be a concave shape, or something looking like a V or U. 

To handle collisions with concave shapes is very tricky... Usually people just don't bother and chop their concave shapes up into simpler, convex shapes and then run collision detection algorithms on them. 

This is what we are also going to do. Most people use triangles as the simpler polygon base and they use a process called triangulation to do that. Triangulation is not a trivial problem and has more than one solution! Let's look at one of them known as the "Ear Clipping Algorithm".

## The Ear Clipping Algorithm *or* how to triangulate Polygons

Triangulating Polygons is a tough problem, because there are so many weird edge cases to deal with. There have been whole papers written about how to efficiently do it (see [resources](#triangulation-resources) below) and I won't go into too much detail here, and neither will I attempt to fix all the possible edge cases. 

The algorithm we are going to use for triangulating concave shapes into a bunch of convex triangles is known as "Ear Clipping".

Ear Clipping? 

Well, glad you asked ^^

The basic idea is to find "ears" – triangular pieces of the polygon that "stick out", like an ear, and then "clip" them out of the polygon, reducing the problem to a smaller polygon – for which we can then another ear to clip, and so on until only a last triangle is left.

Let's define what an "ear" is more formally. An ear is a set of three consecutive vertices, a, b and c, if two conditions are met:

1. The interior angle between edge $\overline{ab}$, and $\overline{bc}$ has to be smaller than 180°
2. The triangle formed by the three vertices can not contain any other vertices of the polygon. 

When an ear is found, we put it into our list of triangles for the triangulation, remove the vertices from the list of vertices to check, and keep looping over the rest of the vertices left and check for another ear. We can keep doing this until just 3 vertices are left – those will form the last ear. In code this would look something like this: 

```typescript
function triangulate(p: Vec2[]) {
  const n = vertices.length - 1;
  if (n < 3) return [];

  // assemble the list of vertices to check
  let indexList: number[] = vertices.map((_, i) => i)
  
  let triangles = [];
  let triangleIndexCount = 0;

  let i = 0;
  while (indexList.length > 3) {
    // this is a hack –> in case the internal angle is exactly 180° – the loop would run forever
    if (i++ > 1000) {
      break;
    }
    for (let i = 0; i < indexList.length; i++) {
      let a = indexList[i];
      let b = getItem(indexList, i - 1);
      let c = getItem(indexList, i + 1);

      let va = vertices[a];
      let vb = vertices[b];
      let vc = vertices[c];

      // calculate edges
      let va_to_vb = vb.sub(va);
      let va_to_vc = vc.sub(va);

      // check the inner angle between the two edges
      // this uses the "perpendicular dot product" – the 2D analog of the cross product.
      // if this is 0 or smaller than 0 the angle is greater than 180° 
      if (va_to_vb.perpDot(va_to_vc) < 0) {
        continue;
      }

      let isEar = true;
      for (let j = 0; j < vertices.length; j++) {
        // skip if vertex is part of ear
        if (j === a || j === b || j === c) {
          continue;
        }

        // check if vertex is in triangle
        if (isPointInTriangle({ p: vertices[j], triangle: { b: vb, a: va, c: vc } })) {
          isEar = false;
          break;
        }
      }

      // add ear vertex indeces to triangulation
      if (isEar) {
        triangles[triangleIndexCount++] = b;
        triangles[triangleIndexCount++] = a;
        triangles[triangleIndexCount++] = c;
        indexList.splice(i, 1);
        break;
      }
    }
  }

  // loop is done, one triangle remaining, add it to the list as well.
  triangles[triangleIndexCount++] = indexList[0];
  triangles[triangleIndexCount++] = indexList[1];
  triangles[triangleIndexCount++] = indexList[2];

  return triangles;
}

// helper function to determine whether or not a point is within a triangle
type Triangle = { a: Vec2; b: Vec2; c: Vec2 }
function isPointInTriangle({p, triangle: { a, b, c }}: { p: Vec2; triangle: Triangle }) {
  const v0 = c.sub(a);
  const v1 = b.sub(a);
  const v2 = p.sub(a);
  
  
  const dot00 = v0.dot(v0);
  const dot01 = v0.dot(v1);
  const dot02 = v0.dot(v2);
  const dot11 = v1.dot(v1);
  const dot12 = v1.dot(v2);

  const denom = dot00 * dot11 - dot01 * dot01;
  const u = (dot11 * dot02 - dot01 * dot12) / denom;
  const v = (dot00 * dot12 - dot01 * dot02) / denom;

  return u >= 0 && v >= 0 && u + v < 1;
}

// helper function to "wrap around" from the end/beginning when indexing into an array
function getItem<T>(arr: T[], i: number) {
  if (i >= arr.length) {
    return arr[i % arr.length];
  } else if (i < 0) {
    return arr[(i % arr.length) + arr.length];
  }
  return arr[i];
}
```

<Triangulation />


For now, this is it, with something like the above, you could have collision detection of arbitrary shapes, by carving them up into neat little triangles and then running collision detection on those. You could even constrain and stop the shapes from moving into each other by adding a collision response. 

However... Collision detection is a tricky business and there are still edge cases where the above breaks down. 

The first that comes to mind are curved shapes – anything that doesn't really have vertices doesn't work with the above algorithms and we would need to convert it first. Also the triangulation implemented doesn't handle holes and breaks if the interior angle between two edges of a polygon is exactly equal to 180° or the polygon intersects with itself. Most of these problems could be tackled simply by using a better triangulation algorithm, but this article is way too long already. In case you are curious I have a list of resources down below!

Another problem could be objects or shapes that move very very quickly. If they move quickly enough and the step size is bigger than the thing they should collide with, they could simply pass through (or "over") the other object. In games, usually bullets and thin walls would show this kind of behavior and problem. It's like the shape were "tunneling" through the other shape, because it moved so fast that there never was a position update where the two were overlapping... 

Yet another problem is that of performance when there are lots of things that could potentially collide with each other. I mean, all of the above code is written for clarity rather than performance so there are improvements to be gained in "simply" rewriting the collision code we have, but the problem of checking collisions for many shapes at once still remains $O(n^2)$. Which is really bad... 

What if n is more than 2? If it is 10, 100, 1000? Collision detection algorithms of any kind are expensive and if we have to check every single polygon against every single other polygon the amount of computations we have to do grows exponentially which will break very soon. 

This really means we have to use some clever data-structure or algorithm to reduce the amount of collisions to check drastically. 

One way to do so would be to divide up the "space" into separate regions or "buckets". Because two shapes which are very very far apart can not intersect (unless one of them is really really big) we could cut down on the number of collision detections we actually have to do by a lot, because only things from the same bucket could potentially collide with one another. 

The general algorithm that could be used for that is called a Quadtree (in 2D) or and Octree (in 3d). Here's an image of the idea in 3D:

![octree visualization](/assets/blog/octree.png)

But coding these is reserved for another time.



If you came all this way – congratulations! I hope you learned something. You can inspect most of the code for the demos of this website at the repo for this page [over here](https://github.com/trebeljahr/trebeljahr.com/tree/collision-detection-article/src/components/collision-detection). 

## Resources 

If you want to read more, I have assembled a list of resources for this project that I used while building. Here you go:



### Triangulation 

